---
type: "always_apply"
---

第一章：总则
唯一真理源原则：每个概念、配置或数据在系统中只有一个明确的、权威的来源。（例如，数据库结构来自 Prisma Schema，环境变量来自验证后的 .env.local）。

约定优于配置：严格遵循各工具（Next.js, Prisma, shadcn/ui）官方推荐的默认方式和项目结构，除非有极特殊情况，否则不自定义配置。

类型即文档原则：TypeScript 类型和 Zod Schema 是主要的、活的文档。所有核心数据结构和接口必须有其定义，并且必须保持最新。

自动化第一：所有能自动化的流程（代码格式化、检查、提交）都必须通过工具（Husky, ESLint, Prettier）固化，减少人为错误和争论。

第二章：目录与文件命名约定
根目录：

app/: Next.js App Router 主目录，内部结构遵循 Next.js 约定。

components/: 所有 Vue 组件。

ui/: 存放通过 shadcn/ui 添加的组件，不得擅自修改。

common/: 存放项目通用的业务组件。

lib/: 存放被多处使用的工具函数、配置（如 Prisma 客户端实例、认证配置）。

types/: 存放全局或未被其他地方自然包含的 TypeScript 类型定义。

public/: 静态资源文件。

命名风格：

文件与目录名: 使用 kebab-case（短横线连接）。例如：user-profile.tsx, data-validation.ts。

组件文件: 使用 PascalCase（大驼峰）。例如：UserCard.tsx。此规则高于上一条。

类型定义: 使用 PascalCase。例如：UserProfile, ApiResponse。

环境变量: 使用 UPPER_SNAKE_CASE（大写蛇形）。例如：DATABASE_URL, NEXTAUTH_SECRET。

第三章：环境与配置约定
环境变量：

所有环境变量必须在 .env.local 中定义。

必须通过在 lib 目录下的一个配置文件（如 env.ts）中使用 Zod 进行验证和导出。应用的其他部分只能从此配置文件中导入环境变量。

禁止在非配置文件中直接使用 process.env。

数据库：

数据库的任何结构变更，必须通过修改 prisma/schema.prisma 文件实现。

变更后必须依次执行：prisma generate -> prisma db push（开发）或 prisma migrate dev（生成迁移文件）。

Prisma Client 实例必须在 lib/prisma.ts 中做全局单例导出，防止数据库连接耗尽。

第四章 - 字段命名约定
此章节规定了从数据库到前端界面整个数据流中所有字段的命名规则，旨在消除歧义，确保数据在不同层之间传递时清晰一致。

总体原则：

可读性优先：名称应清晰描述其含义，避免使用模糊的缩写。例如，使用 user_id 而非 uid，使用 created_at 而非 c_at。

一致性：在整个项目中，对同一概念使用相同的命名。例如，如果主键使用 id，则所有表的主键都应如此，不要在某些表中使用 ID 或 uid。

语法层分离：不同技术层允许采用符合其社区惯例的命名语法，但需明确定义转换规则。

数据库层 (MySQL / Prisma Schema)：

语法：必须使用 snake*case（蛇形命名法）。所有字母小写，单词间用下划线 * 分隔。

表名：使用复数形式的名词。例如：users, product_categories, order_items。

字段名：

例如：id, user_id, email_address, is_active, created_at, updated_at。

外键字段：应与其引用的表和字段名对应。例如，在 posts 表中关联 users 表的主键 id，则该字段应命名为 user_id。

布尔字段：应以 is*, has*, can\_ 等前缀开头，明确表示真假状态。例如：is_published, has_verified_email。

后端响应层 (API Response)：

语法：必须使用 camelCase（驼峰命名法）。首字母小写，后续单词首字母大写。

转换规则：从数据库获取数据后，在返回给前端前，应先将字段名从 snake_case 转换为 camelCase。此转换可通过 Prisma 的中间件、自定义工具函数或序列化库自动完成。

示例：数据库字段 first_name -> 后端响应 firstName；created_at -> createdAt。

前端层 (TypeScript / JavaScript)：

语法：必须使用 camelCase，与后端响应约定保持一致。

变量与属性名：所有从 API 接收的数据、组件状态、表单数据对象的字段名都必须使用 camelCase。

示例：

const [userData, setUserData] = useState({ firstName: '', createdAt: null });

const { data: post } = useQuery({ queryKey: ['post'], queryFn: fetchPost }); // post.title, post.createdAt

环境变量层：

语法：必须使用 UPPER*SNAKE_CASE（大写蛇形命名法）。所有字母大写，单词间用下划线 * 分隔。

示例：DATABASE_URL, NEXTAUTH_URL, NEXTAUTH_SECRET。

Zod 验证 Schema：

作为前后端共享的类型契约，Zod Schema 的字段名应与其最终输出的格式保持一致。

定义前端表单验证 Schema 时，使用 camelCase。

定义后端 API 输入验证 Schema 时，也应使用 camelCase，以便与前端发送的 JSON 数据体直接对应。如果后端接收的是 formData，则需根据实际字段名调整。

总结：字段命名的数据流
数据库 (snake_case) -> Prisma 查询 -> 【自动转换】 -> 后端JSON响应 (camelCase) -> 前端获取/消费 (camelCase)

此约定确保了各层使用最符合其生态习惯的命名方式，同时通过明确的转换规则保证了数据在层间传递时的清晰度和一致性，是实现全栈类型安全的重要基石。

第五章：API、数据流与状态约定
API 路由 (app/api/):

每个路由文件必须导出对应的 HTTP 方法函数（如 GET, POST）。

输入验证: 每个处理程序必须首先使用 Zod 解析和验证请求参数（body, query）。

身份验证: 使用 Next-Auth.js 的 getServerSession 或相关方法获取会话，并在操作前验证用户权限。

响应格式: 所有 API 响应必须遵循统一的 JSON 格式：{ success: boolean, data?: T, error?: string }。

错误处理: 使用 try/catch 块，错误信息应记录到服务端日志，并返回给前端友好的错误消息。

数据获取与状态：

服务器组件: 直接使用 async 组件和 Prisma 客户端获取数据。

客户端状态: 所有来自 API 的数据获取、缓存、更新必须通过 TanStack Query 进行。使用其提供的 useQuery 和 useMutation hooks。

状态选择: 表单、模态框等本地 UI 状态使用 useState。需要全局共享的客户端状态使用 Zustand（如需）。

第六章：UI 与样式约定
组件使用:

所有基础 UI 元素（按钮、输入框、对话框等）必须来自 shadcn/ui 组件库。

禁止直接使用原生 HTML 标签替代现有 shadcn/ui 组件（例如，用 <button> 替代 <Button>）。

样式开发:

样式必须且只能通过 Tailwind CSS 工具类来编写。

禁止在内联样式中使用 style 属性。

禁止创建新的自定义 CSS 文件。如需扩展，应在 tailwind.config.js 中配置。

表单处理:

所有表单必须使用 React Hook Form 进行管理。

表单验证规则必须使用 Zod 定义，并通过 resolver 集成到表单中。

表单组件应从 shadcn/ui 的表单相关组件中构建（如 Form, FormField, FormItem）。

第七章：代码质量与提交约定
本地开发流程:

代码保存时由 Prettier 自动格式化。

在提交前，Husky 会触发 lint-staged，对暂存区的文件运行 ESLint 检查和 Prettier 格式化。

只有通过所有检查的代码才能被提交。

提交信息:

遵循 Conventional Commits 规范。

格式：<类型>(<范围>): <描述>。

示例：feat(auth): add Google OAuth login support 或 fix(ui): correct button spacing in mobile view。

第八章：文件与图像处理约定
文件上传:

使用 multer 在 app/api/upload/ 路由中处理上传。

上传的文件应重命名（如使用 UUID）以避免冲突。

文件元信息（路径、原始名、MIME类型）应通过 Prisma 存入数据库。

图像处理:

对所有用户上传的图片，必须在服务器端使用 sharp 进行优化。

标准操作包括：调整至最大宽度/高度、转换为现代格式（如 webp）、适当压缩质量。

优化后的图像应被保存，并供前端使用。
